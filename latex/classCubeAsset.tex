\hypertarget{classCubeAsset}{}\section{Cube\+Asset Class Reference}
\label{classCubeAsset}\index{Cube\+Asset@{Cube\+Asset}}


{\ttfamily \#include $<$Cube\+Asset.\+h$>$}



Inheritance diagram for Cube\+Asset\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classCubeAsset__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Cube\+Asset\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classCubeAsset__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCubeAsset_ac506cff57e5656238caf95872582d976}{Cube\+Asset} (G\+Lfloat position\+X, G\+Lfloat position\+Y, G\+Lfloat position\+Z)
\item 
\hyperlink{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}{$\sim$\+Cube\+Asset} ()
\item 
virtual void \hyperlink{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}{Draw} (G\+Luint)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classCubeAsset_ac506cff57e5656238caf95872582d976}{}\index{Cube\+Asset@{Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\index{Cube\+Asset@{Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{Cube\+Asset(\+G\+Lfloat position\+X, G\+Lfloat position\+Y, G\+Lfloat position\+Z)}]{\setlength{\rightskip}{0pt plus 5cm}Cube\+Asset\+::\+Cube\+Asset (
\begin{DoxyParamCaption}
\item[{G\+Lfloat}]{position\+X, }
\item[{G\+Lfloat}]{position\+Y, }
\item[{G\+Lfloat}]{position\+Z}
\end{DoxyParamCaption}
)}\label{classCubeAsset_ac506cff57e5656238caf95872582d976}
based on the coloured cube tutorial stored float data for the rgb values of the cubes vertices 
\begin{DoxyCode}
5                                                                            \{
6   \textcolor{comment}{// model coordinates, origin at centre.}
7   GLfloat vertex\_buffer\_data [] \{
8         -0.5f + positionX, -0.5f + positionY, -0.5f + positionZ,
9         -0.5f + positionX,  0.5f + positionY, -0.5f + positionZ,
10          0.5f + positionX, -0.5f + positionY, -0.5f + positionZ,
11          0.5f + positionX,  0.5f + positionY, -0.5f + positionZ,
12          0.5f + positionX, -0.5f + positionY,  0.5f + positionZ,
13          0.5f + positionX,  0.5f + positionY,  0.5f + positionZ,
14         -0.5f + positionX, -0.5f + positionY,  0.5f + positionZ,
15         -0.5f + positionX,  0.5f + positionY,  0.5f + positionZ
16   \};
17   GLfloat vertex\_buffer\_length = \textcolor{keyword}{sizeof}(vertex\_buffer\_data);
18 
19 
21    GLfloat g\_colour\_buffer\_data[] = \{
22 
23 
24         0.502f, 0.502f, 0.502f,
25         0.502f, 0.502f, 0.502f,
26         0.502f, 0.502f, 0.502f,
27         0.502f, 0.502f, 0.502f,
28         0.502f, 0.502f, 0.502f,
29         0.502f, 0.502f, 0.502f,
30         0.502f, 0.502f, 0.502f,
31         0.502f, 0.502f, 0.502f
32 
33   \};
34     colour\_buffer\_length = \textcolor{keyword}{sizeof}(g\_colour\_buffer\_data);
35 
36 
37   GLuint element\_buffer []  \{
38         0, 1, 2,
39         1, 3, 2,
40         2, 3, 4,
41         3, 5, 4,
42         0, 2, 4,
43         6, 0, 4,
44         6, 7, 0,
45         1, 0, 7,
46         1, 7, 3,
47         7, 5, 3,
48         5, 6, 4,
49         5, 7, 6
50   \};
51   element\_buffer\_length = \textcolor{keyword}{sizeof}(element\_buffer);
52 
53 
54 
55   \textcolor{comment}{// Transfer buffers to the GPU}
56   \textcolor{comment}{//}
57 
58   \textcolor{comment}{// create buffer}
59   glGenBuffers(1, &vertex\_buffer\_token);
60   \textcolor{comment}{// immediately bind the buffer and transfer the data}
61   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
62   glBufferData(GL\_ARRAY\_BUFFER, vertex\_buffer\_length, vertex\_buffer\_data, GL\_STATIC\_DRAW);
63 
64 
65     glGenBuffers(1, &colour\_buffer\_token);
66     glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
67     glBufferData(GL\_ARRAY\_BUFFER, colour\_buffer\_length, g\_colour\_buffer\_data, GL\_STATIC\_DRAW);
68 
69 
70   glGenBuffers(1, &element\_buffer\_token);
71   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
72   glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_length, element\_buffer, GL\_STATIC\_DRAW);
73 \}
\end{DoxyCode}
\hypertarget{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}{}\index{Cube\+Asset@{Cube\+Asset}!````~Cube\+Asset@{$\sim$\+Cube\+Asset}}
\index{````~Cube\+Asset@{$\sim$\+Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{$\sim$\+Cube\+Asset()}]{\setlength{\rightskip}{0pt plus 5cm}Cube\+Asset\+::$\sim$\+Cube\+Asset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}

\begin{DoxyCode}
75                       \{
76 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}{}\index{Cube\+Asset@{Cube\+Asset}!Draw@{Draw}}
\index{Draw@{Draw}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{Draw(\+G\+Luint)}]{\setlength{\rightskip}{0pt plus 5cm}void Cube\+Asset\+::\+Draw (
\begin{DoxyParamCaption}
\item[{G\+Luint}]{program\+\_\+token}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}


Implements \hyperlink{classGameAsset_a961aa51ca0a9961fc584c0b5d5431300}{Game\+Asset}.


\begin{DoxyCode}
93                                          \{
94   \textcolor{keywordflow}{if}(!glIsProgram(program\_token)) \{
95     std::cerr << \textcolor{stringliteral}{"Drawing Cube with invalid program"} << std::endl;
96     \textcolor{keywordflow}{return};
97   \}
98   GLint validation\_ok;
99   glValidateProgram(program\_token);
100   glGetProgramiv(program\_token, GL\_VALIDATE\_STATUS, &validation\_ok);
101   \textcolor{keywordflow}{if}(!validation\_ok) \{
102     GLint maxLength = 0;
103     glGetProgramiv(program\_token, GL\_INFO\_LOG\_LENGTH, &maxLength);
104 
105     \textcolor{comment}{//The maxLength includes the NULL character}
106     std::vector<char> errorLog(maxLength);
107     glGetProgramInfoLog(program\_token, maxLength, &maxLength, &errorLog[0]);
108 
109     std::cerr << \textcolor{stringliteral}{"Invalid program "} << program\_token << \textcolor{stringliteral}{" with error code "} << validation\_ok << std::endl;
110     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} c: errorLog) \{
111       std::cerr << c;
112     \}
113     exit(-1);
114   \}
115 
116   GLuint position\_attrib = glGetAttribLocation(program\_token, \textcolor{stringliteral}{"position"});
117   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
118 
119   glUseProgram(program\_token);
120   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
121 
122   \textcolor{comment}{// use the previously transferred buffer as the vertex array.  This way}
123   \textcolor{comment}{// we transfer the buffer once -- at construction -- not on every frame.}
124   glEnableVertexAttribArray(0);
125   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
126   glVertexAttribPointer(
127     0,        \textcolor{comment}{/* attribute */}
128     3,        \textcolor{comment}{/* size */}
129     GL\_FLOAT,   \textcolor{comment}{/* type */}
130     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
131     0,        \textcolor{comment}{/* stride */}
132     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
133   );
134   glEnableVertexAttribArray(1);
135   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
136 
137   glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
138   glVertexAttribPointer(
139     1,        \textcolor{comment}{/* attribute */}
140     3,        \textcolor{comment}{/* size */}
141     GL\_FLOAT,   \textcolor{comment}{/* type */}
142     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
143     0,        \textcolor{comment}{/* stride */}
144     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
145   );
146   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
147 
148   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
149   glDrawElements(
150     GL\_TRIANGLES,
151     element\_buffer\_length,
152     GL\_UNSIGNED\_INT,
153     (GLvoid*) 0
154   );
155   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
156 
157   glDisableVertexAttribArray(position\_attrib);
158 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{CubeAsset_8h}{Cube\+Asset.\+h}\item 
src/\hyperlink{CubeAsset_8cc}{Cube\+Asset.\+cc}\end{DoxyCompactItemize}
